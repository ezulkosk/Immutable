/*
 * Type system for object initialization, as described in:
 * "Freedom Before Commitment" by Alexander J. Summers and 
 * Peter Muller. 
 * 
 * Course Project: ECE750 Spring 2013
 * Author: Ed Zulkoski
 */
package javacop.initrules;
flowfact InitFlowFacts;

/*---------------------------------------*/
/* Define the initialization annotations */
/*---------------------------------------*/

declare free(Symbol s){
	require(s.hasAnnotation("javacop.annotations.Free"));
}

declare unclassified(Symbol s){
	require(s.hasAnnotation("javacop.annotations.Unclassified"));
}

//we default to Committed
declare committed(Symbol s){
	require(explicitlyCommitted(s) || (!free(s) && !unclassified(s)));
}

declare committed(JCTree t){
	require(t.holdsSymbol && committed(t.getSymbol));
}

declare explicitlyCommitted(JCTree t){
	require(t.holdsSymbol && explicitlyCommitted(t.getSymbol));
}

declare explicitlyCommitted(Symbol s){
	require(s.hasAnnotation("javacop.annotations.Committed"));
}

/*-----------------------------------*/
/* Define the mutability annotations */
/*-----------------------------------*/

declare mutable(Symbol s){
	require(s.hasAnnotation("javacop.annotations.Mutable"));
}

//For now, default to immutable
declare immutable(Symbol s){
	require(s.hasAnnotation("javacop.annotations.Immutable")
			|| !mutable(s));
}

declare immutable(JCTree t){
	require(t.holdsSymbol && immutable(t.getSymbol));
}

/*-----------------------*/

declare definitelyAssignedVariable(JCAssign a){
	require(InitFlowFacts ff ; ff <- a#getFlowFacts(InitFlowFacts#class)){
		require(ff#hasBeenInitialized(a.lhs));
	}
}


rule assign(JCAssign a){
	where(a.lhs.holdsSymbol && committed(a.lhs.getSymbol)){
		require(committed(a.rhs) /*definitelyAssignedVariable(a)*/): warning(a, "Left committed but defAssVar failed.");
	}
}

// T_Var_Ass
// if lhs is a field access of a committed immutable object, error 
//  (unless it's a self-assignment (a.lhs = a.lhs), but not worth handling)
rule tvarass(JCAssign a){
	require(1 < 2);
}

/*
rule test2(JCAssign a){
	require(InitFlowFacts ff ; ff <- a#getFlowFacts(InitFlowFacts#class)){
		where(ff#testMeth(a.lhs) && a.lhs.holdsSymbol){
			require(JCTree l, Symbol s; l <- a.lhs && s <- a.lhs.getSymbol){
				where(l instanceof JCFieldAccess 
						//the implicit-this case
						|| (l instanceof JCIdent && !(s.isLocal || s.isStatic))){
					require(/*!committed(l) false):warning(a, "TEST2");
				}
			}
		}
	}
}
*/

rule test(JCTree a){
	require(a.holdsSymbol): warning(a,"Never hit.");
}

/*--------------------*/
/* Sanity Constraints */	
/*--------------------*/

//A node must satisfy "free xor committed xor unclassified"
declare singleInitAnnotation(Symbol s){
	require(!(free(s) && explicitlyCommitted(s)) 
			&& !(free(s) && unclassified(s))
			&& !(explicitlyCommitted(s) && unclassified(s)));
}

rule singleInitAnnotation(JCVariableDecl vd){
	where(vd.holdsSymbol){
		require(singleInitAnnotation(vd.getSymbol))
		:warning(vd,"VarDecl can have only one of: [@Free,@Classified,@Unclassified].");
	}
}

rule singleInitAnnotation(JCMethodDecl md){
	where(md.holdsSymbol){
		require(singleInitAnnotation(md.getSymbol))
		:warning(md,"MethodDecl can have only one of: [@Free,@Classified,@Unclassified].");
	}
}

//A node must satisfy "mutable xor immutable"
declare singleMutationAnnotation(Symbol s){
	require(mutable(s) ^ immutable(s));
}

rule singleMutationAnnotation(JCVariableDecl vd){
	where(vd.holdsSymbol){
		require(singleMutationAnnotation(vd.getSymbol)):warning(vd,"VarDecl can have only one of: [@Mutable,@Immutable].");
	}
}

rule singleMutationAnnotation(JCMethodDecl md){
	where(md.holdsSymbol){
		require(singleMutationAnnotation(md.getSymbol)):warning(md,"MethodDecl can have only one of: [@Mutable,@Immutable].");
	}
}

//A constructor should not have an initialization modifier
declare noInitAnnotation(Symbol s){
	require(!free(s) && !explicitlyCommitted(s) && !unclassified(s));
}

rule noInitAnnotation(JCMethodDecl md){
	where(md.holdsSymbol && md.getSymbol.isConstructor){
		require(noInitAnnotation(md.getSymbol)):warning(md, "Constructors should not have initialization modifiers.");
	}
}

//A field should not have an initialization modifier
rule noInitAnnotation(JCVariableDecl vd){
	where(vd.holdsSymbol && !vd.getSymbol.isStatic && !vd.getSymbol.isLocal){
		require(noInitAnnotation(vd.getSymbol)):warning(vd, "Fields should not have initialization modifiers.");
	}
}
